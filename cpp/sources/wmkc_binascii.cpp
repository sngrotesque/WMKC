#include <wmkc_binascii.hpp>

static const wmkcByte hexTable[256] = {
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f};

wmkcByte wmkc::binascii::toTop(wmkcByte c)
{
    return ((c >> 4) < 0xa) ? ((c >> 4) + 0x30) : ((c >> 4) + 0x57);
}

wmkcByte wmkc::binascii::toBot(wmkcByte c)
{
    return ((c & 0xf) < 0xa) ? ((c & 0xf) + 0x30) : ((c & 0xf) + 0x57);
}

std::string wmkc::binascii::b2a_hex(std::string content)
{
    if(content.empty()) {
        return std::string();
    }
    wmkcSize i;
    wmkcByte *src = (wmkcByte *)content.c_str();
    wmkcSize srcSize = content.size();

    wmkcByte *dst = new wmkcByte[srcSize << 1];
    if(!dst) {
        wmkc::exception(wmkcErr_ErrMemory, "wmkc::binascii::b2a_hex",
            "Failed to allocate memory for dst.");
    }

    for(i = 0; i < srcSize; ++i) {
        dst[i << 1]       = this->toTop(src[i]);
        dst[(i << 1) + 1] = this->toBot(src[i]);
    }

    std::string result((wmkcChar *)dst, srcSize << 1);
    delete[] dst;
    return result;
}

std::string wmkc::binascii::a2b_hex(std::string content)
{
    if(content.empty()) {
        return std::string();
    }
    wmkcSize srcIndex, dstIndex;
    wmkc_s32 top, bot;

    wmkcByte *src = (wmkcByte *)content.c_str();
    wmkcSize srcSize = content.size();
    wmkcByte *dst = nullptr;

    if(srcSize & 1) {
        wmkc::exception(wmkcErr_Err, "wmkc::binascii::a2b_hex",
            "Wrong type, should not be an odd length.");
    }

    if(!(dst = new wmkcByte[srcSize >> 1])) {
        wmkc::exception(wmkcErr_ErrMemory, "wmkc::binascii::a2b_hex",
            "Failed to allocate memory for dst.");
    }

    for(srcIndex = dstIndex = 0; srcIndex < srcSize; srcIndex += 2, ++dstIndex) {
        top = hexTable[src[srcIndex]];
        bot = hexTable[src[srcIndex + 1]];
        if((top == 0x1f) || (bot == 0x1f)) {
            delete[] dst;
            wmkc::exception(wmkcErr_Err, "wmkc::binascii_a2b_hex",
                "Wrong type, characters must be from 0 to f.");
        }
        dst[dstIndex] = (top << 4) + bot;
    }

    std::string result((wmkcChar *)dst, srcSize >> 1);
    delete[] dst;
    return result;
}
